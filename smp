package gdelt;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/** 
 * @author 
 */
/*** A java class to download, MD5 validate and unzip a global dataset ***/
public class DownloadData {

	private static final Logger log = Logger.getLogger(DownloadData.class.getName());		

	public int run(String dL, String hC, String uZ, String freq, String startRange, String endRange, String compFmt, String confProp) throws ParseException, IOException, NoSuchAlgorithmException {

		/*** To fetch data from property file ***/
		Properties prop = new Properties();
		InputStream in = new FileInputStream(confProp);			
		prop.load(in);
		String zip = prop.getProperty("zip").trim();
		String raw = prop.getProperty("raw").trim();
		String csvzip = prop.getProperty("csvzip").trim();
		String url = prop.getProperty("url").trim();
		String md5url = prop.getProperty("md5url").trim();
		String ypath = prop.getProperty("ypath").trim();
		String mpath = prop.getProperty("mpath").trim();
		String dpath = prop.getProperty("dpath").trim();
		String md5sums = prop.getProperty("md5sums").trim();

		log.info("Program started...");		
		log.info("Below parameters have been entered...");
		log.info("Download Y/N ==> " +dL);
		log.info("HashCompare Y/N ==> " +hC);
		log.info("UnZip Y/N ==> " +uZ);
		log.info("Freq ==> " +freq);
		log.info("Start Range ==> " +startRange);
		log.info("End Range ==> " +endRange);
		log.info("compFmt ==> " +compFmt);
		log.info("Conf Property ==> " +confProp);

		try {

			/*** To download file based on input frequency - Yearly(Y/y)/Monthly(M/m)/Daily(D/d) ***/ 
			switch (freq) {

			// Yearly 
			case "Y":
			case "y":

				//Get list of files YEAR wise between start and end date given
				for(int i=Integer.parseInt(startRange); i<=Integer.parseInt(endRange); i++){

					// Path to download yearly files
					String sYearlyPath = ypath +i +raw +i +zip;

					//Download file from given URL
					if ("Y".equalsIgnoreCase(dL)) {												
						downloadFromUrl(url +i +zip, sYearlyPath);												
					} 

					//Download MD5SUM published file & validate it against calcuated MD5
					if ("Y".equalsIgnoreCase(hC)) {						
						downloadFromUrl(md5url , ypath +i +raw +md5sums);
						final String downloadedFile = sYearlyPath;
						hashCompare(ypath +i +raw +md5sums, downloadedFile);
					}

					//Unzip validated file
					if ("Y".equalsIgnoreCase(uZ)) {
						String zipFilePath = sYearlyPath;
						String destDir = ypath +i +raw +i ;
						unzip(zipFilePath, destDir);
					}

				}
				break;

				// Monthly
			case "M":
			case "m":

				//Get list of files MONTH wise between start and end date given
				DateFormat formatter = new SimpleDateFormat("yyyyMM");
				Calendar begCal = Calendar.getInstance();
				Calendar finCal = Calendar.getInstance();
				begCal.setTime(formatter.parse(startRange));
				finCal.setTime(formatter.parse(endRange));

				while(begCal.before(finCal)){
					String date = formatter.format(begCal.getTime()).toUpperCase();
					begCal.add(Calendar.MONTH, 1);

					if (dL == "Y") {
						//Download GDELT file					
						downloadFromUrl(url +date +zip, mpath +date +raw +date +zip);						
					}

					if (hC == "Y") {
						//Download MD5SUM file
						downloadFromUrl(md5url , mpath +date +raw +md5sums);
						//MD5 check
						final String downloadedFile = mpath +date +raw +date +zip;
						hashCompare(mpath +date +raw +md5sums, downloadedFile);
					}

					if (uZ == "Y") {
						//Unzip
						String zipFilePath = mpath +date +raw +date +zip;
						String destDir = mpath +date +raw +date;					
						unzip(zipFilePath, destDir);
					}
				}

				break;

				//Daily
			case "D":
			case "d":
				/*** Get list of files DATE wise between start and end date given ***/
				List<Date> dates = new ArrayList<Date>();			
				DateFormat formatter1 = new SimpleDateFormat("yyyyMMdd");
				Date startDate = formatter1.parse(startRange);
				Date endDate = formatter1.parse(endRange);
				long interval = 24*1000*60*60;
				long endTime = endDate.getTime();
				long curTime = startDate.getTime();

				while (curTime <=endTime){
					dates.add(new Date(curTime));
					curTime += interval;
				}

				for(int i=0;i<dates.size();i++){
					Date lDate=dates.get(i);
					String ds = formatter1.format(lDate);

					if (dL == "Y") {
						//Download GDELT file
						downloadFromUrl(url +ds +csvzip, dpath +ds +raw +ds +csvzip);						
					}

					if (hC == "Y") {
						//Download MD5SUM file
						downloadFromUrl(md5url , dpath +ds +raw +md5sums);
						//MD5 check
						final String downloadedFile = dpath +ds +raw +ds +csvzip;
						hashCompare(dpath +ds +raw +md5sums, downloadedFile);
					}

					if (uZ == "Y") {				
						//Unzip
						String zipFilePath = dpath +ds +raw +ds +csvzip;
						String destDir = dpath +ds +raw +ds;						
						unzip(zipFilePath, destDir);
					}

				}
				break;
			}
		}
		catch (IOException e) {
			e.printStackTrace();
		}

		log.info("Program Completed Successfully...");

		return 0;
	}

	/** Method to download file from the given URL
	 * @param urlStr
	 * @param file
	 * @throws IOException
	 */
	private static void downloadFromUrl(String urlStr, String file) throws IOException{

		log.info("file ******* " +file);
		log.info("urlStr ******* " +urlStr);
		//Check if Target zip file already exists
		File tgtFile = new File(file);
		if (tgtFile.exists()){
			log.info("Target ZIP file already exists");
			System.exit(5);
		}		

		/*	//Set Proxy details
		System.getProperties().put("proxySet","true");
		System.getProperties().put("http.proxyHost","proxy.jpmchase.net");
		System.getProperties().put("http.proxyPort","8443");
		 */
		URL url = new URL(urlStr);
		HttpURLConnection httpConn = (HttpURLConnection)url.openConnection();
		int rc = httpConn.getResponseCode();

		//Check if Source file present or not
		if (rc != HttpURLConnection.HTTP_OK) {
			log.info("File not present - please check " +rc +" => " +urlStr);
			System.exit(4);
		}

		log.info("Downloading starts" +urlStr);

		// create Output directory if it doesn't exist
		if(!tgtFile.exists()){
			log.info("Target File ***** " +tgtFile);
			log.info("Target's Parent File ***** " +tgtFile.getParentFile());
			tgtFile.getParentFile().mkdirs();
		}

		BufferedInputStream bis = new BufferedInputStream(url.openStream());
		FileOutputStream fis = new FileOutputStream(file);
		byte[] buffer = new byte[1024];
		int count=0;

		while((count = bis.read(buffer,0,1024)) != -1)
		{
			fis.write(buffer, 0, count);
		}

		fis.close();
		bis.close();
		log.info("Downloading " +file +" complete");
	}

	/**
	 * @param zipFilePath
	 * @param destDir
	 */
	private static void unzip(String zipFilePath, String destDir) {
		File dir = new File(destDir);

		// create Output directory if it doesn't exist
		if(!dir.exists()) dir.mkdirs();

		//buffer for read and write data to file
		byte[] buffer = new byte[1024];
		try {

			FileInputStream fis = new FileInputStream(zipFilePath);
			ZipInputStream zis = new ZipInputStream(fis);
			ZipEntry ze = zis.getNextEntry();

			while(ze != null){
				String fileName = ze.getName();
				File newFile = new File(destDir + File.separator + fileName);
				log.info("Unzipping to "+newFile.getAbsolutePath());

				//create directories for sub directories in zip
				new File(newFile.getParent()).mkdirs();
				FileOutputStream fos = new FileOutputStream(newFile);
				int len;
				while ((len = zis.read(buffer)) > 0) {
					fos.write(buffer, 0, len);
				}
				fos.close();

				//close this ZipEntry
				zis.closeEntry();
				ze = zis.getNextEntry();
			}
			//close last ZipEntry
			zis.closeEntry();
			zis.close();
			fis.close();

			log.info("Unzip Complete");

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * @param sFilePath - Published file
	 * @param downloadedFile - Downloaded zip file
	 * @throws NoSuchAlgorithmException
	 */
	private static void hashCompare (String sFilePath, String downloadedFile) throws NoSuchAlgorithmException {

		MessageDigest digest = MessageDigest.getInstance("MD5");

		//Create checksum for the Downloaded file
		File f = new File(downloadedFile);

		String actual;

		try {
			actual = getFileChecksum(digest, f);
		} catch (IOException e){
			e.printStackTrace();
			throw new RuntimeException("Unable to process file for MD5", e);
		}

		//print Downloaded file Checksum
		log.info("Actual checksum " +actual);

		//to get the Filename and pass to get expected checksum
		Path p = Paths.get(downloadedFile);
		String file1 = p.getFileName().toString();

		//expected checksum
		String expected = null;
		try{
			expected = expectedChecksum(sFilePath, file1);
		} catch (IOException e){
			e.printStackTrace();
		}

		//compare checksum
		try{
			boolean isValid = compareFileChecksum(expected, actual);
			log.info("Is MD5 validation fine?" +isValid);
			if (!isValid){
				throw new IOException();
			}
		} catch (IOException e) {
			log.info("MD5 check failed");
			e.printStackTrace();
			System.exit(1);
		}
	}

	public static String getFileChecksum(MessageDigest digest, File file) throws IOException{

		//Get file input stream for reading file content
		FileInputStream fis = new FileInputStream(file);

		//Create byte array to read data in chunks
		byte[] byteArray = new byte[1024];
		int bytesCount = 0;

		//Read file data and update in message digest
		while((bytesCount = fis.read(byteArray)) != -1){
			digest.update(byteArray, 0, bytesCount);
		};

		//close the stream
		fis.close();

		//Get the hash's bytes
		byte[] bytes = digest.digest();

		//This bytes[] has bytes in decimal format - Convert it to hexadecimal format
		StringBuilder sb = new StringBuilder();
		for (int i=0; i<bytes.length; i++){
			sb.append(Integer.toString((bytes[i]& 0xff) + 0x100,16).substring(1));
		}

		//return complete hash
		return sb.toString();
	}

	private static boolean compareFileChecksum(String expected, String actual){
		if (expected!=null && expected.equals(actual)){
			return true;
		}
		else{
			return false;
		}
	}

	public static String expectedChecksum(String publishedFile, String sFileName) throws IOException {
		FileReader fr = new FileReader(publishedFile);
		BufferedReader br = new BufferedReader(fr);
		String line ="";
		Map<String,String> hMap = new HashMap<String,String>();

		while ((line=br.readLine())!= null){
			String[] strArray = line.split("\\s+");
			hMap.put(strArray[0], strArray[1]);
		}

		String sCheckSum = (String)getKeyFromValue(hMap,sFileName);
		log.info("Expected checksum" +sCheckSum);
		return sCheckSum;
	}  

	public static Object getKeyFromValue(Map hm, Object value) {
		for (Object o:hm.keySet()){
			if (hm.get(o).equals(value)){
				return o;
			}
		}
		return null;
	}
}
